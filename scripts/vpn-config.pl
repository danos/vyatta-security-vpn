#!/usr/bin/perl
#
# Module: vpn-config.pl
#
# **** License ****
# Copyright (c) 2017-2019, AT&T Intellectual Property.  All rights reserved.
# Copyright (c) 2014-2017, Brocade Communications Systems, Inc.
# All Rights Reserved.
#
# This code was originally developed by Vyatta, Inc.
# Portions created by Vyatta are Copyright (C) 2006-2012 Vyatta, Inc.
# All Rights Reserved.
#
# Description: Start Openswan VPN based on verified configuration
#
# **** End License ****
#

# SPDX-License-Identifier: GPL-2.0-only

use strict;
use warnings;

use constant IKELIFETIME_DEFAULT => 28800;    # 8 hours
use constant ESPLIFETIME_DEFAULT => 3600;     # 1 hour
use constant REKEYMARGIN_DEFAULT => 540;      # 9 minutes
use constant REKEYFUZZ_DEFAULT   => 100;
use constant INVALID_LOCAL_IP    => 254;
use constant VPN_MAX_PROPOSALS   => 10;

use Getopt::Long;
use NetAddr::IP;
use File::Basename;
use File::Path qw(make_path remove_tree);
use File::Copy;
use File::Slurp;

use lib "/opt/vyatta/share/perl5";
use Vyatta::TypeChecker;
use Vyatta::Config;
use Vyatta::VPN::Util qw(enableICMP is_tcp_udp is_vpn_running
                         rsa_get_local_pubkey vpn_debug uniq
                         rsa_pubkey_to_rfc2537 get_pki_key_type
                         vpn_die vpn_exec vpn_log get_intf);

use Vyatta::Misc;
use Vyatta::DHCPClient;
use Vyatta::VPN::VTIIntf qw(discoverVtiIntfs isVtimarkpresent);
use Vyatta::VPN::Config qw(rsa_get_local_key_file validate_local_key_file
                      get_ike_modp_default conv_pfs_to_dh_group
                      generate_conn_ike_proposal generate_conn_esp
                      conv_protocol_all
                      write_charon_logging_conf);
use Vyatta::VPN::OPMode qw(get_vpnprof_tunnels);

my $config_file;
my $secrets_file;
GetOptions(
  "config_file=s"   => \$config_file,
  "secrets_file=s"  => \$secrets_file
);
my $CA_CERT_PATH = '/etc/ipsec.d/cacerts';
my $CRL_PATH = '/etc/ipsec.d/crls';

my $vpn_cfg_err = "VPN configuration error:";
my $clustering_ip = 0;
my $dhcp_if = 0;
my $genout;
my $genout_secrets;
my $genout_shunts;
my $scriptname = $0;

$genout_secrets .= "# generated by $scriptname\n\n";
$genout_shunts  .= "# generated by $scriptname\n\n";

#
# Add shunt policy where required.
#
sub add_shunt {
  my $con = shift;
  my $proto = shift;
  my $ls = shift;
  my $rs = shift;
  my $l = shift;
  my $r = shift;
  my $lport = shift;
  my $rport = shift;

  return if (!-f '/opt/vyatta/etc/features/vyatta-security-vpn-ipsec-v1/tunnel-shunting');

  return if (index($con, '-tunnel-vti') != -1);

  my $lefts = '';
  my $rights = '';
  my $iplen = 32;
  if ($proto == 6) {
    $iplen = 128;
  }

  if (defined($ls) && ($ls ne '0.0.0.0/0')) {
    $lefts = $ls;
  } elsif (defined($l)) {
    $lefts = "$l/$iplen";
  }
  if (defined($rs) && ($rs ne '0.0.0.0/0')) {
    $rights = $rs;
  } elsif (defined($r)) {
    $rights="$r/$iplen";
  }
  $genout_shunts .= "\nconn shunt-$con\n";
  $genout_shunts .= "\tleftsubnet=$lefts\n" if $lefts ne '';
  $genout_shunts .= "\tleftprotoport=$lport\n" if defined $lport;
  $genout_shunts .= "\trightsubnet=$rights\n" if $rights ne '';
  $genout_shunts .= "\trightprotoport=$rport\n" if defined $rport;
  $genout_shunts .= "\tauthby=never\n";
  $genout_shunts .= "\ttype=drop\n";
  $genout_shunts .= "\tauto=route\n";

  return;
}

#
# Prepare Vyatta::Config object
#
my $vc    = Vyatta::Config->new();
my $vcVPN = Vyatta::Config->new('security vpn');

if ( $vcVPN->exists('l2tp remote-access') ) {
  # check if dhcp-interface or outside-address is configured,
  # policy should be disabled for that dataplane interface
  my $l2tp_intf;
  if ( $vcVPN->exists('l2tp remote-access outside-address') ) {
    my $ifp = $vcVPN->returnValue('l2tp remote-access outside-address');
    $l2tp_intf = get_intf($ifp);
  } else {
    $l2tp_intf = $vcVPN->returnValue('l2tp remote-access dhcp-interface');
  }
  if (defined ($l2tp_intf)) {
    chomp($l2tp_intf);
    $l2tp_intf =~ s/\./\//g;
    vpn_exec("sysctl net.ipv4.conf.$l2tp_intf.disable_policy=1 >&/dev/null",
             'VPN toggle net.ipv4.conf.intf.disable_policy');
  }
} elsif ( $vcVPN->isDeleted('l2tp remote-access') && !$vcVPN->exists('ipsec esp-group') ) {
  my $l2tp_intf;
  if ( $vcVPN->existsOrig('l2tp remote-access outside-address') ) {
    my $ifp = $vcVPN->returnOrigValue('l2tp remote-access outside-address');
    $l2tp_intf = get_intf($ifp);
  } else {
    $l2tp_intf = $vcVPN->returnOrigValue('l2tp remote-access dhcp-interface');
  }
  unless ($l2tp_intf eq '') {
    chomp($l2tp_intf);
    $l2tp_intf =~ s/\./\//g;
    vpn_exec("sysctl net.ipv4.conf.$l2tp_intf.disable_policy=0 >&/dev/null",
             'VPN toggle net.ipv4.conf.<intf>.disable_policy');
  }
}

# check to see if the config has changed.
# if it has not then exit
my $ipsecstatus = $vcVPN->exists('ipsec') && $vcVPN->isChanged('ipsec') || $vcVPN->isDeleted('ipsec');
my $rsastatus = $vcVPN->exists('rsa-keys') && $vcVPN->isChanged('rsa-keys') || $vcVPN->isDeleted('rsa-keys');
if (!$ipsecstatus && !$rsastatus) {
    my $tun_ip_changed = 0;
    my $tun_disable_changed = 0;
    my @tuns           = $vc->listNodes('interfaces tunnel');
    my @profs          = $vcVPN->listNodes('ipsec profile');
    foreach my $prof (@profs) {
        my @tuns = $vcVPN->listNodes("ipsec profile $prof bind tunnel");
        foreach my $tun (@tuns) {
            if ( $vc->isChanged("interfaces tunnel $tun disable") ||
                 $vc->isDeleted("interfaces tunnel $tun disable")) {
                $tun_disable_changed = 1;
                last;
            }
            my $lip_old =
              $vc->returnOrigValue("interfaces tunnel $tun local-ip");
            if (!defined($lip_old)) {
                my $local_intf = $vc->returnOrigValue("interfaces tunnel $tun local-interface");
                if (defined($local_intf)) {
                    foreach ( split( '\n', `ip addr show $local_intf` ) ) {
                        if (/inet (\d+\.\d+\.\d+\.\d+)/) {
                            $lip_old = $1;
                        }
                    }
                }
            }
            my $lip_new = $vc->returnValue("interfaces tunnel $tun local-ip");
            if (!defined($lip_new)) {
                my $local_intf = $vc->returnValue("interfaces tunnel $tun local-interface");
                if (defined($local_intf)) {
                    foreach ( split( '\n', `ip addr show $local_intf` ) ) {
                        if (/inet (\d+\.\d+\.\d+\.\d+)/) {
                              $lip_new = $1;
                        }
                    }
                }
            }
            if (!defined($lip_new)) {
                print STDERR "\nCouldn't derive local address for Tunnel $tun";
            }
            if ( $lip_old ne $lip_new ) {
                $tun_ip_changed = 1;
                last;
            }
        }
    }
    if ( !$tun_ip_changed && !$tun_disable_changed ) {
        exit 0;
    }
}

# track changed peers, profiles, etc. that need to get restarted to apply
# the configuration changes
my @CHANGED_IKE_SAS;
my @CHANGED_CHILD_SAS;

if ( $vcVPN->exists('ipsec') ) {

  #
  # Check that ESP groups have been specified
  #
  my @esp_groups = $vcVPN->listNodes('ipsec esp-group');
  if ( @esp_groups == 0 ) {

    #print STDERR "$vpn_cfg_err No ESP groups configured." .
    #             " At least one ESP group required.\n";
    # XXX for now this will be checked below for site-to-site peer

  } else {
    foreach my $esp_group (@esp_groups) {
      my @esp_group_proposals =
        $vcVPN->listNodes("ipsec esp-group $esp_group proposal");
      if ( @esp_group_proposals == 0 ) {
        vpn_die(["security", "vpn", "ipsec", "esp-group", $esp_group, "proposal"],
                "$vpn_cfg_err No proposals configured for ESP group \"$esp_group\""
                . ".  At least one proposal required.\n");
      } elsif ( @esp_group_proposals > VPN_MAX_PROPOSALS ) {
        vpn_die(["security", "vpn", "ipsec", "esp-group", $esp_group],
        "$vpn_cfg_err A total of "
          . scalar @esp_group_proposals
          . " proposals have been configured for ESP group \"$esp_group\"."
          . " The maximum proposals allowed for an ESP group is "
          . VPN_MAX_PROPOSALS . "\n");
      } else {
        foreach my $esp_group_proposal (@esp_group_proposals) {
          my $esp_group_proposal_encryption = $vcVPN->returnValue(
            "ipsec esp-group $esp_group proposal $esp_group_proposal encryption"
          );
          if ( !defined($esp_group_proposal_encryption)
            || $esp_group_proposal_encryption eq "" )
          {
            vpn_die(["security", "vpn", "ipsec", "esp-group", $esp_group, "proposal", $esp_group_proposal, "encryption"],
					  "$vpn_cfg_err No encryption specified for ESP group "
					  . "\"$esp_group\" proposal $esp_group_proposal.\n");
	    
          }
          my $esp_group_proposal_hash = $vcVPN->returnValue(
            "ipsec esp-group $esp_group proposal $esp_group_proposal hash");
          if ( !defined($esp_group_proposal_hash)
            || $esp_group_proposal_hash eq "" )
          {
	          vpn_die(["security", "vpn", "ipsec", "esp-group", $esp_group, "proposal", $esp_group_proposal, "hash"],
					    "$vpn_cfg_err No hash specified for ESP group \"$esp_group\""
					    . " proposal $esp_group_proposal.\n");
	        }
        }
      }
    }

    # Disable policy checks on v4 traffic to allow locally-destined
    # traffic over a site-to-site VPN to be received by the kernel instead
    # of being dropped
    toggle_xfrm_policy(1);
  }

  #
  # Check that IKE groups have been specified
  #
  my @ike_groups = $vcVPN->listNodes('ipsec ike-group');
  if ( @ike_groups == 0 ) {

    #print STDERR "$vpn_cfg_err No IKE groups configured." .
    #             "  At least one IKE group required.\n";
    # XXX for now this will be checked below for site-to-site peer

  } else {
    foreach my $ike_group (@ike_groups) {
      my @ike_group_proposals =
        $vcVPN->listNodes("ipsec ike-group $ike_group proposal");
      if ( @ike_group_proposals == 0 ) {
	      vpn_die(["security", "vpn", "ipsec", "ike-group", $ike_group, "proposal"],
				    "$vpn_cfg_err No proposals configured for IKE group \"$ike_group\""
				    . ".  At least one proposal required.\n");
      } elsif ( @ike_group_proposals > VPN_MAX_PROPOSALS ) {
        vpn_die(["security", "vpn", "ipsec", "ike-group", $ike_group],
        "$vpn_cfg_err A total of "
          . @ike_group_proposals
          . " proposals have been configured for IKE group \"$ike_group\"."
          . " The maximum proposals allowed for an IKE group is "
          . VPN_MAX_PROPOSALS . "\n");
      } else {
        foreach my $ike_group_proposal (@ike_group_proposals) {
          my $ike_group_proposal_encryption = $vcVPN->returnValue(
            "ipsec ike-group $ike_group proposal $ike_group_proposal encryption"
          );
          if ( !defined($ike_group_proposal_encryption)
            || $ike_group_proposal_encryption eq "" )
          {
	          vpn_die(["security", "vpn", "ike-group", $ike_group, "proposal", $ike_group_proposal, "encryption"],
					    "$vpn_cfg_err No encryption specified for IKE group "
					    . "\"$ike_group\" proposal $ike_group_proposal.\n");
          }
          my $ike_group_proposal_hash = $vcVPN->returnValue(
            "ipsec ike-group $ike_group proposal $ike_group_proposal hash");
          if ( !defined($ike_group_proposal_hash)
            || $ike_group_proposal_hash eq "" )
          {
            vpn_die(["security", "vpn", "ike-group", $ike_group, "proposal", $ike_group_proposal, "hash"],
					  "$vpn_cfg_err No hash specified for IKE group \"$ike_group\""
					  . " proposal $ike_group_proposal.\n");
          }
        }
      }
    }
  }

  #
  # Check the local key file
  # Note: $local_key_file will be used later when reading the keys
  #
  my $running_local_key_file = rsa_get_local_key_file();
  my $local_key_file         = $vcVPN->returnValue('rsa-keys local-key file');
  if ( !defined($local_key_file) ) {
    $local_key_file = $Vyatta::VPN::Config::LOCAL_KEY_FILE_DEFAULT;
  }
  if ( $local_key_file ne $running_local_key_file ) {
      eval { validate_local_key_file($local_key_file) };
      vpn_die(["security", "vpn", "rsa-keys", "local-key", "file"],
              "$vpn_cfg_err " . $@) if ($@);
  }
  if ( -r $running_local_key_file && !( -e $local_key_file ) ) {
      vpn_debug "cp $running_local_key_file $local_key_file";
      my $dirpath = dirname($local_key_file);
      my $err;
      mkpath($dirpath, { error => \$err });
      if (@{$err}) {
          vpn_die(["security", "vpn", "rsa-keys", "local-key", "file"],
                  "$vpn_cfg_err Could not copy previous local RSA key file "
                  . "\"$running_local_key_file\" to new local RSA key file "
                  . "\"$local_key_file\".  Could not mkdir [$dirpath] $!\n");
      }
      if (! copy($running_local_key_file, $local_key_file)) {
          vpn_die(["security", "vpn", "rsa-keys", "local-key", "file"],
                  "$vpn_cfg_err Could not copy previous local RSA key file "
                  . "\"$running_local_key_file\" to new local RSA key file "
                  . "\"$local_key_file\".  $!\n");
      }
  }
  # try migration to PEM if we find a RAW format key file
  if ( -e $local_key_file ) {
      vpn_log("Checking for RSA private key in RAW format\n");

      my @lines = read_file($local_key_file, err_mode => 'quiet');
      if (grep { /\s+\#pubkey=\S+/ } @lines) {
          copy($local_key_file, $local_key_file . ".raw") || die "cannot backup file $local_key_file";
          vpn_exec("/opt/vyatta/bin/vyatta-pki --raw_to_pem "
                   . "--file=$local_key_file.raw > $local_key_file",
                   'Convert local RSA private key from RAW to PEM format' );
      }
  }

  #
  # Version 2
  #
  $genout .= "version 2.0\n";
  $genout .= "\n";
  $genout .= "config setup\n";

  #
  # Defaults
  #
  $genout .= "\n";
  $genout .= "conn %default\n";

  #
  # Default keyengine is ikev1
  #
  $genout .= "\tkeyexchange=ikev1\n";

  #
  # Disable IKEv2 MOBIKE for now (RFC 4555)
  #
  $genout .= "\tmobike=no\n";

  #
  # Keep default IKE fragementation. Got chaned in strongswan 5.5.1
  #
  $genout .= "\tfragmentation=no\n";

  #
  # End of defaults
  #
  $genout .= "\n";

  #
  # Connection configurations
  #
  my @peers = $vcVPN->listNodes('ipsec site-to-site peer');
  if (   @peers == 0
      && !( $vcVPN->exists('l2tp') )
      && !( $vcVPN->exists('ipsec profile') )
      && !( $vcVPN->exists('ipsec remote-access-client') )
      && !( $vcVPN->exists('ipsec remote-access-server') ) )
  {
      print "VPN Warning: IPsec configured but no site-to-site peers or l2tp"
        . " remote-users configured\n";
  }
  my $prev_peer = "";
  discoverVtiIntfs();
  foreach my $peer (@peers) {
    my $peer_ike_group =
      $vcVPN->returnValue("ipsec site-to-site peer $peer ike-group");
    if ( !defined($peer_ike_group) || $peer_ike_group eq '' ) {
      vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "ike-group"],
				  "$vpn_cfg_err No IKE group specified for peer \"$peer\".\n");
    } elsif ( !$vcVPN->exists("ipsec ike-group $peer_ike_group") ) {
      vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "ike-group"],
				  "$vpn_cfg_err The IKE group \"$peer_ike_group\" specified for peer "
				  . "\"$peer\" has not been configured.\n");
    }

    my $lip = $vcVPN->returnValue("ipsec site-to-site peer $peer local-address");

    my $peer_proto =  ((is_ip_v4_or_v6($peer) && (is_ip_v4_or_v6($peer) == 6))) ? 6 : 4;
    my $conn_proto = 4;

    # Check peer and local-address consistency
    if ($peer_proto == 6) {
         if (defined($lip)) {
              if (is_ip_v4_or_v6($lip) && (is_ip_v4_or_v6($lip) == 6)) {
                  $conn_proto = 6;
              } else {
                  # Protocols don't match
                  if (isIpAddress($lip)) {
                      vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "local-address"],
	                       "$vpn_cfg_err The 'local-address' and peer protocols do not match");
                  # %any for IPv6 IKEv1 is not supported by StrongS/WAN
                  } elsif($lip eq 'any') {
                      vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "local-address"],
                               "$vpn_cfg_err 'any' local address is not supported for IPv6 peers");
                  }
              }
         } else {
              $conn_proto = 6;
         }
    }

    my $default_pfx = ($conn_proto == 4) ? '0.0.0.0/0' : '::/0';
    my $dhcp_iface = $vcVPN->returnValue("ipsec site-to-site peer $peer dhcp-interface");
    if (defined($lip) && defined($dhcp_iface)){
      vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer],
        "$vpn_cfg_err Only one of local-address or dhcp-interface may be defined");
    }
    if (defined($dhcp_iface)){
      $dhcp_if = $dhcp_if + 1;
      $lip = get_dhcp_addr($dhcp_iface, $peer, $peer_proto);
    }
    my $authid =
      $vcVPN->returnValue("ipsec site-to-site peer $peer authentication id");
    my $authremoteid = $vcVPN->returnValue(
      "ipsec site-to-site peer $peer authentication remote-id");
    if ( (!defined($lip) || $lip eq "") && (!defined($dhcp_iface) || $dhcp_iface eq "") ) {
      vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "local-address"],
        "$vpn_cfg_err No local-address specified for peer \"$peer\"\n");
    } elsif ( $lip ne 'any' ) {

      # not 'any' special case.
      # check interface addresses.
      if ( !Vyatta::Misc::is_local_address($lip) ) {
        vpn_log(
"The local-address $lip of peer \"$peer\" has not been configured on the system.\n");
        if ( Vyatta::Misc::isClusterIP( $vc, $lip ) ) {

          # Verified that dealing with a cluster IP.
          $clustering_ip = 1;
        } elsif (!defined($dhcp_iface)) {
          print
            "Warning: Local address $lip specified for peer \"$peer\"\n" .
            "is not configured on the system and is not the clustering\n" .
            "address.  IPsec must be re-started after address has\n" .
            "been configured.\n\n";
        }
      }
    }
    
    #
    # Default ESP group
    #
    my $def_esp_group = $vcVPN->returnValue("ipsec site-to-site peer $peer default-esp-group");
    $def_esp_group = '' if !defined($def_esp_group);
    if ( !$vcVPN->exists("ipsec esp-group $def_esp_group") ) {
        vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "default-esp-group"],
				    "$vpn_cfg_err The ESP group \"$def_esp_group\" specified "
				    . "for peer \"$peer\" has not been configured.\n");
    }

    #
    # Name connection by peer and tunnel
    #
    my $isVti = 0;
    my @tunnels = $vcVPN->listNodes("ipsec site-to-site peer $peer tunnel");
    if ( @tunnels == 0 ) {
      #
      # Check if this is VTI
      #
      if ($vcVPN->exists("ipsec site-to-site peer $peer vti") ) {
            $isVti = 1;
            @tunnels = (@tunnels, "vti");
      }
      if (@tunnels == 0) {
            vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "tunnel"],
                    "$vpn_cfg_err No tunnels configured for peer \"$peer\".  At least"
                    . " one tunnel required per peer.\n");
      }
    } else {
      #
      # Check if this is VTI
      #
      if ($vcVPN->exists("ipsec site-to-site peer $peer vti") ) {
            vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "vti"],
                    "$vpn_cfg_err Both Vti and tunnel(s) configured for peer \"$peer\n");
      }
    }

    my @deleted_tunnels = $vcVPN->listOrigNodes("ipsec site-to-site peer $peer tunnel");
    foreach my $deleted_tunnel (@deleted_tunnels) {
      if ($vcVPN->isDeleted("ipsec site-to-site peer $peer tunnel $deleted_tunnel")) {
         my $conn = "peer-$peer-tunnel-$deleted_tunnel";
         push(@CHANGED_CHILD_SAS, $conn);
      }
    }

    foreach my $tunnel (@tunnels) {

      my $needs_passthrough = 'false';

      my $conn = "peer-$peer-tunnel-$tunnel";
      $conn =~ s/peer-@/peer-/;

      my $conn_head = "\nconn $conn\n";
      $genout .= $conn_head;

      my $tunKeyword;
      if ($isVti == 1) {
        $tunKeyword = 'vti';
      } else {
        $tunKeyword = 'tunnel '."$tunnel";
      }

      my $peer_tunnel_esp_group = $vcVPN->returnValue(
        "ipsec site-to-site peer $peer $tunKeyword esp-group");
      $peer_tunnel_esp_group = '' if (!defined($peer_tunnel_esp_group));
      if (($peer_tunnel_esp_group eq '') && ( $def_esp_group eq '')) {
        vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, $tunKeyword, "esp-group"],
				    "$vpn_cfg_err No ESP group specified for peer \"$peer\" "
				    . "$tunKeyword.\n");
      } elsif ( !$vcVPN->exists("ipsec esp-group $peer_tunnel_esp_group") ) {
        vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, $tunKeyword, "esp-group"],
				    "$vpn_cfg_err The ESP group \"$peer_tunnel_esp_group\" specified "
				    . "for peer \"$peer\" $tunKeyword has not been configured.\n");
      }
      
      if ($vcVPN->isChanged("ipsec site-to-site peer $peer authentication") ||
          $vcVPN->isChanged("ipsec site-to-site peer $peer connection-type") ||
          $vcVPN->isChanged("ipsec site-to-site peer $peer dhcp-interface") ||
          $vcVPN->isChanged("ipsec site-to-site peer $peer ike-group") ||
          $vcVPN->isChanged("ipsec site-to-site peer $peer local-address") ||
          $vcVPN->isChanged("ipsec ike-group $peer_ike_group")) {
          push(@CHANGED_IKE_SAS, $conn);
      }
      elsif (($peer_tunnel_esp_group &&
           $vcVPN->isChanged("ipsec esp-group $peer_tunnel_esp_group")) ||
           ($def_esp_group &&
           $vcVPN->isChanged("ipsec esp-group $def_esp_group")) ||
           $vcVPN->isChanged("ipsec site-to-site peer $peer tunnel $tunnel") ||
           $vcVPN->isChanged("ipsec site-to-site peer $peer vti")) {
          push(@CHANGED_CHILD_SAS, $conn);
      }

      #
      # Add support for tunnel disable.
      #
      if (!$isVti &&
        $vcVPN->exists("ipsec site-to-site peer $peer $tunKeyword disable") )
      {
        next;
      } elsif ($isVti) {
        my $intfName =
        $vcVPN->returnValue("ipsec site-to-site peer $peer vti bind");

        if ($vc->exists("interfaces vti $intfName disable")) {
          next;
        }
      }

      # Support for dhcp-interfaces
      # The comment dhcp-interface will be used by the dhclient hook to do connection updates.
      if (defined($dhcp_iface)){
        $genout .= "\t\#dhcp-interface=$dhcp_iface\n";
        $lip = get_dhcp_addr($dhcp_iface, $peer, $peer_proto);
      }

      # -> leftsourceip is the internal source IP to use in a tunnel
      # -> we use leftsourceip to add a route to the rightsubnet
      #    only when rightsubnet is defined and is not 0.0.0.0/0. we do not
      #    want to add a vpn route for everything i.e. rightsubnet = 0.0.0.0/0
      #
      # NOTE: Configuring a leftsourceip lets charon enter modecfg mode!
      #
      my $leftsourceip = undef;

      #
      # Assign left and right to local and remote interfaces
      #
      if ( defined($lip) ) {
        if ( $lip eq 'any' ) {
          if ($isVti) {
            vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, $tunKeyword, "local-address"],
                    "$vpn_cfg_err The local interface must be specified "
                    . "for peer \"$peer\" $tunKeyword.\n");
          }
          $genout .= "\tleft=%any\n";
          # no need for leftsourceip as a defaultroute is must for this to work
        } else {
          $genout .= "\tleft=$lip\n";
        }
        $genout .= "\tleftid=\"$authid\"\n" if defined $authid;
      }

      # @SM Todo: must have explicit settings for VTI.
      my $any_peer = 0;
      my $right;
      my $rightid = undef;
      if ( $peer =~ /^\@/ ) {

        # peer is an "ID"
        $rightid  = $peer;
        $any_peer = 1;
      } elsif ($authremoteid) {
        $rightid = $authremoteid;
      }
      if ( ( $peer eq 'any' )
        or ( $peer eq '0.0.0.0' )
        or ( $peer eq '0:0:0:0:0:0:0:0' )
        or $any_peer == 1 )
      {
        if ($isVti) {
           vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer],
             "$vpn_cfg_err The \"$peer\" is invalid "
             . "ip address must be specified for $tunKeyword.\n");
        }
        $right    = '%any';
        $any_peer = 1;
      } else {
        $right = $peer;
      }
      $genout .= "\tright=$right\n";
      $genout .= "\trightid=\"$rightid\"\n" if ( defined($rightid) );
      if ($any_peer) {
        $genout .= "\trekey=no\n";
      }

      #
      # Write tunnel configuration
      #

      #
      # Protocol/port
      #
      my $protocol = $vcVPN->returnValue(
          "ipsec site-to-site peer $peer $tunKeyword protocol");
      my $lprotoport = '';
      if (defined($protocol)){
          $lprotoport .= conv_protocol_all($protocol);
      }
      my $lport = $vcVPN->returnValue(
          "ipsec site-to-site peer $peer $tunKeyword local port");
      if (defined($lport)){
          if (!defined($protocol)){
            $lprotoport .= "0/$lport";
          } elsif (is_tcp_udp($protocol)){
            $lprotoport .= "/$lport";
          } else {
            vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "tunnel", $tunnel, "local", "port"],
                "$vpn_cfg_err local port can only be defined when protocol is tcp, udp, or undefined.\n");
          }
      }

      my $rprotoport = '';
      if (defined($protocol)){
          $rprotoport .= conv_protocol_all($protocol);
      }
      my $rport = $vcVPN->returnValue(
          "ipsec site-to-site peer $peer $tunKeyword remote port");
      if (defined($rport)){
          if (!defined($protocol)){
            $rprotoport .= "0/$rport";
          } elsif (is_tcp_udp($protocol)){
            $rprotoport .= "/$rport";
          } else {
            vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "tunnel", $tunnel, "remote", "port"],
                "$vpn_cfg_err remote port can only be defined when protocol is tcp, udp, or undefined.\n");
          }
      }

      my $leftsubnet = $vcVPN->returnValue(
        "ipsec site-to-site peer $peer $tunKeyword local prefix");
      if ( (defined($leftsubnet) && $leftsubnet eq 'any') || $isVti == 1 ) {
        $leftsubnet = $default_pfx;
      }

      if ( defined($leftsubnet) ) {

        if ($lprotoport ne '') {
          $leftsubnet .= "[$lprotoport]";
        }

        $genout .= "\tleftsubnet=$leftsubnet\n";
      } else {
        if ($lprotoport ne '') {
          $genout .= "\tleftprotoport=$lprotoport\n";
        }
      }

      my $remotesubnet = $vcVPN->returnValue(
        "ipsec site-to-site peer $peer $tunKeyword remote prefix");
      if ($isVti) {
        $remotesubnet = 'any';
      }

      # Check local and remote prefix protocol consistency
      my $leftsubnet_proto = is_ip_v4_or_v6($leftsubnet);
      $leftsubnet_proto ||= is_ip_v4_or_v6($lip);
      my $remotesubnet_proto = is_ip_v4_or_v6($remotesubnet);
      $remotesubnet_proto ||= is_ip_v4_or_v6($right);
      if ( !$isVti && ($leftsubnet_proto != $remotesubnet_proto) ) {
          vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "tunnel", $tunnel],
                   "$vpn_cfg_err The 'remote prefix' and 'local prefix' protocols ".
                   "do not match");
      }
      # Check remote/local and peer protocol consistency
      # IPv6 over IPv6 scenario is actually supported by StrongS/WAN,
      # we do not allow it in this version because of design and QA issues.
      if (($conn_proto != 6) && ($leftsubnet_proto == 6)) {
          vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "tunnel", $tunnel],
                   "$vpn_cfg_err IPv6 over IPv4 IPsec is not supported");
     } elsif (($conn_proto == 6) && ($leftsubnet_proto != 6)) {
	  vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "tunnel", $tunnel],
                  "$vpn_cfg_err IPv4 over IPv6 IPsec is not supported");
     }

      my $rightsubnet = $remotesubnet;
      if ( defined($rightsubnet) && $rightsubnet eq 'any' ) {
        $rightsubnet = $default_pfx;
      }

      if ( defined($rightsubnet) ) {

        if ($rprotoport ne '') {
          $rightsubnet .= "[$rprotoport]";
        }

        $genout .= "\trightsubnet=$rightsubnet\n";

        # not adding vpn route if remote prefix is 0.0.0.0/0
        # user should add a route [default/static] manually
        $leftsourceip = undef if $rightsubnet eq $default_pfx;
        if ($rightsubnet =~ /vhost:%priv/) {
          # can't add route when rightsubnet is not specific
          $leftsourceip = undef;
        }
      } else {
        $leftsourceip =
          undef;    # no need for vpn route if rightsubnet not defined
        if ($rprotoport ne '') {
          $genout .= "\trightprotoport=$rprotoport\n";
        }
      }

      $genout .= $leftsourceip if defined $leftsourceip;

      #
      # check if passthrough connection is needed
      # needed when remote-subnet encompasses local-subnet
      #
      if (!$isVti && defined $leftsubnet && defined $rightsubnet) {
        # validate that these values are ipv4net
        my $valid_leftsubnet = 'false';
        my $valid_rightsubnet = 'false';

        $valid_leftsubnet = 'true' if validateType( 'ipv4net', $leftsubnet, 'quiet' );
        $valid_rightsubnet = 'true' if validateType( 'ipv4net', $rightsubnet, 'quiet' );

        if ($valid_leftsubnet eq 'true' && $valid_rightsubnet eq 'true') {

          my $localsubnet_object = NetAddr::IP->new($leftsubnet);
          my $remotesubnet_object = NetAddr::IP->new($rightsubnet);
          if ($remotesubnet_object == $localsubnet_object) {
            vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer],
                "$vpn_cfg_err local prefix and remote prefix cannot be the same.\n");
          }
          if ($remotesubnet_object->contains($localsubnet_object)) {
            $needs_passthrough = 'true';
          } 
        }
      }

      #
      # Write IKE configuration from group
      #
      my $ikelifetime = IKELIFETIME_DEFAULT;
      my $ike_group =
        $vcVPN->returnValue("ipsec site-to-site peer $peer ike-group");
      if ( defined($ike_group) && $ike_group ne '' ) {
        my $strict_mode = ! $vcVPN->exists(
          "ipsec ike-group $ike_group disable-strict-mode");
        $genout .= "\t# warning: disabling strict-mode\n" unless ($strict_mode);

        my $ikeversion =
          $vcVPN->returnValue("ipsec ike-group $ike_group ike-version");
        if ($ikeversion) {
            if ($ikeversion eq '2+1') {
                $genout .= "\tkeyexchange=ike\n";
            } else {
                $genout .= "\tkeyexchange=ikev$ikeversion\n";
            }
        }

        $genout .= "\tike=";
        my @ike_proposals =
          $vcVPN->listNodes("ipsec ike-group $ike_group proposal");

        my $first_ike_proposal = 1;
        foreach my $ike_proposal (@ike_proposals) {

          #
          # Get encryption, hash & Diffie-Hellman  key size
          #
          my $encryption = $vcVPN->returnValue(
            "ipsec ike-group $ike_group proposal $ike_proposal encryption");
          my $hash = $vcVPN->returnValue(
            "ipsec ike-group $ike_group proposal $ike_proposal hash");
          my $dh_group = $vcVPN->returnValue(
            "ipsec ike-group $ike_group proposal $ike_proposal dh-group");

          #
          # Write separator if not first proposal
          #
          if ($first_ike_proposal) {
            $first_ike_proposal = 0;
          } else {
            $genout .= ",";
          }

          #
          # Write values
          #
          $genout .= eval { generate_conn_ike_proposal($encryption, $hash,
                                                       $dh_group); };
          vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer,
                   "tunnel", $tunnel],
                  "$vpn_cfg_err Invalid 'dh-group' $dh_group specified for "
                  . "peer \"$peer\" $tunKeyword.  Only 2 or 5 accepted.\n")
              if $@;
        }
        $genout .= '!' if ($strict_mode);
        $genout .= "\n";

        my $t_ikelifetime =
          $vcVPN->returnValue("ipsec ike-group $ike_group lifetime");
        if ( defined($t_ikelifetime) && $t_ikelifetime ne '' ) {
          $ikelifetime = $t_ikelifetime;
        }
        $genout .= "\tikelifetime=$ikelifetime" . "s\n";

        #
        # Check for Dead Peer Detection DPD
        #
        my $dpd_interval = $vcVPN->returnValue(
          "ipsec ike-group $ike_group dead-peer-detection interval");
        my $dpd_timeout = $vcVPN->returnValue(
          "ipsec ike-group $ike_group dead-peer-detection timeout");
        my $dpd_action = $vcVPN->returnValue(
          "ipsec ike-group $ike_group dead-peer-detection action");
        if ( defined($dpd_interval)
          && defined($dpd_timeout)
          && defined($dpd_action) )
        {
          $genout .= "\tdpddelay=$dpd_interval" . "s\n";
          $genout .= "\tdpdtimeout=$dpd_timeout" . "s\n";
          $genout .= "\tdpdaction=$dpd_action\n";
        }
      }

      #
      # Write ESP configuration from group
      #
      my $esplifetime = ESPLIFETIME_DEFAULT;
      my $esp_group = $vcVPN->returnValue(
        "ipsec site-to-site peer $peer $tunKeyword esp-group");
      if (!defined($esp_group) || $esp_group eq ''){
        $esp_group = $vcVPN->returnValue(
          "ipsec site-to-site peer $peer default-esp-group");
      }
      if ( defined($esp_group) && $esp_group ne '' ) {
        my $strict_mode = ! $vcVPN->exists(
          "ipsec esp-group $esp_group disable-strict-mode");
        $genout .= "\t# warning: disabling strict-mode\n" unless ($strict_mode);

        $genout .= "\tesp=";
        my @esp_proposals =
          $vcVPN->listNodes("ipsec esp-group $esp_group proposal");
        my $first_esp_proposal = 1;
        foreach my $esp_proposal (@esp_proposals) {

          #
          # Get encryption, hash
          #
          my $encryption = $vcVPN->returnValue(
            "ipsec esp-group $esp_group proposal $esp_proposal encryption");
          my $hash = $vcVPN->returnValue(
            "ipsec esp-group $esp_group proposal $esp_proposal hash");

          #
          # Write separator if not first proposal
          #
          if ($first_esp_proposal) {
            $first_esp_proposal = 0;
          } else {
            $genout .= ",";
          }

          #
          # Perfect Forward Secrecy
          #
          my $pfs = $vcVPN->returnValue("ipsec esp-group $esp_group pfs");
          if ( defined($pfs) && $pfs eq 'enable' ) {
              my @ike_proposals = $vcVPN->listNodes(
                  "ipsec ike-group $ike_group proposal");
              my @ike_dh_groups;
              foreach my $ike_proposal (@ike_proposals) {
                  my $dh_group = $vcVPN->returnValue(
                      "ipsec ike-group $ike_group proposal $ike_proposal dh-group");
                  push(@ike_dh_groups, get_ike_modp_default($dh_group));
              }

              @ike_dh_groups = uniq(@ike_dh_groups);

              #
              # Write values
              #
              $genout .= join(',', map {
                  generate_conn_esp($encryption, $hash, $_)
              } @ike_dh_groups);
          } else {
              #
              # Write values
              #
              $genout .= generate_conn_esp($encryption, $hash,
                                           conv_pfs_to_dh_group($pfs));
          }
        }
        $genout .= '!' if ($strict_mode);
        $genout .= "\n";

        my $t_esplifetime =
          $vcVPN->returnValue("ipsec esp-group $esp_group lifetime");
        if ( defined($t_esplifetime) && $t_esplifetime ne '' ) {
          $esplifetime = $t_esplifetime;
        }
        $genout .= "\tkeylife=$esplifetime" . "s\n";

        my $lower_lifetime = $ikelifetime;
        if ( $esplifetime < $ikelifetime ) {
          $lower_lifetime = $esplifetime;
        }

        #
        # The lifetime values need to be greater than:
        #   rekeymargin*(100+rekeyfuzz)/100
        #
        my $rekeymargin = REKEYMARGIN_DEFAULT;
        if ( $lower_lifetime <= ( 2 * $rekeymargin ) ) {
          $rekeymargin = int( $lower_lifetime / 2 ) - 1;
        }
        $genout .= "\trekeymargin=$rekeymargin" . "s\n";

        #
        # Mode (tunnel or transport)
        #
        my $espmode = $vcVPN->returnValue("ipsec esp-group $esp_group mode");
        if ( !defined($espmode) || $espmode eq '' ) {
          $espmode = "tunnel";
        }
        if ( $espmode eq "transport" ) {
          if ( defined $leftsubnet or defined $rightsubnet ) {
            vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, $tunKeyword],
              "$vpn_cfg_err Can not use local-subnet or remote-subnet when "
              . "using transport mode\n");
          }
          if ( $isVti == 1) {
            vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, $tunKeyword],
              "$vpn_cfg_err Can not use transport mode for \"$peer\" with vti\n");
          }
        }
        $genout .= "\ttype=$espmode\n";

        #
        # Compression
        #
        my $compression =
          $vcVPN->returnValue("ipsec esp-group $esp_group compression");
        if ( defined($compression) ) {
          if ( $compression eq 'enable' ) {
	    print "WARNING: IPsec header compression is not supported";
            $genout .= "\tcompress=no\n";
          } else {
            $genout .= "\tcompress=no\n";
          }
        }
      }

      #
      # Authentication mode
      #
      #
      # Write shared secrets to ipsec.secrets
      #
      my $auth_mode = $vcVPN->returnValue(
        "ipsec site-to-site peer $peer authentication mode");
      if ( !defined($auth_mode) || $auth_mode eq '' ) {
        vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "authentication"],
             "$vpn_cfg_err No authentication mode for peer \"$peer\" specified.\n");
      } elsif ( defined($auth_mode) && ( $auth_mode eq 'pre-shared-secret' ) ) {
        my $psk = $vcVPN->returnValue(
          "ipsec site-to-site peer $peer authentication pre-shared-secret");
        my $orig_psk = $vcVPN->returnOrigValue(
          "ipsec site-to-site peer $peer authentication pre-shared-secret");
        $orig_psk = "" if (!defined($orig_psk));
        if ($psk ne $orig_psk && $orig_psk ne ""){
          print "WARNING: The pre-shared-secret will not be updated until the next re-keying interval\n";
          print "To force the key change use: 'reset vpn ipsec-peer'\n";
        }
        if ( !defined($psk) || $psk eq '' ) {
          vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "authentication"],
            "$vpn_cfg_err No 'pre-shared-secret' specified for peer \"$peer\""
            . " while 'pre-shared-secret' authentication mode is specified.\n");
        }

        my $right;
        if ( ( $peer eq 'any' )
          or ( $peer eq '0.0.0.0' )
          or ( $peer eq '0:0:0:0:0:0:0:0' )
          or ( $peer =~ /^\@/ ) )
        {
          $right = '%any';
        } else {
          $right = $peer;
        }
        my $index1 = ( defined($authid) )       ? "$authid"       : $lip;
        my $index2 = ( defined($authremoteid) ) ? "$authremoteid" : $right;
        if ($lip eq '0.0.0.0'&&!defined($dhcp_iface)) {
          if ($index1 =~ m/^@/) {
            # In main mode PSK, the responder needs to look up the secret 
            # before the Peer's ID payload has been decoded, so the ID used 
            # will be the IP address. Note that this'll work with aggressive 
            # mode PSK but starting VC6, we use strongswan which doesn't 
            # support aggressive mode. More info on reported bug :
            # http://bugzilla.vyatta.com/show_bug.cgi?id=5500            
	          vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", "0.0.0.0", "authentication"],
					  "$vpn_cfg_err cannot use authentication id with pre-shared-secret"
					  . " when local-address is 0.0.0.0\n");
		}
	    # when local-address is dynamic then only the following generic form works
	    $genout_secrets .= ": PSK \"$psk\"\n";
        } else {
          if (not ($prev_peer eq $peer)){
              $genout_secrets .= write_secrets_id_selectors($dhcp_iface, $lip, $right, $authid, $authremoteid);
	          # tag the secrets lines with 3 entries so the op mode command can
	          # deal with them properly. (LEFT means localid, RIGHT means remoteid)
            if ((!defined($authid)) && (defined($authremoteid))) {
              $genout_secrets .= ": PSK \"$psk\" #RIGHT# ";
            } elsif ((defined($authid)) && (!defined($authremoteid))) {
              $genout_secrets .= ": PSK \"$psk\" #LEFT# ";
            } else {
              $genout_secrets .= ": PSK \"$psk\" ";
            }
            if (defined($dhcp_iface)){
              $genout_secrets .= "#dhcp-interface=$dhcp_iface#\n";
            } else {
              $genout_secrets .= "\n";
            }
          }
          $prev_peer = $peer;
        }
        $genout         .= "\tleftauth=psk\n";
        $genout         .= "\trightauth=psk\n";
        $genout         .= "\trightid=\"%any\"\n" if ( !defined($rightid) );
      } elsif ( defined($auth_mode) && $auth_mode eq 'x509') {
        $genout .= get_x509($peer);
        $genout_secrets .= get_x509_secret($peer);
      } elsif ( defined($auth_mode) && $auth_mode eq 'rsa' ) {

        unless ( -r $local_key_file ) {
          if ( -e $local_key_file ) {
          vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "authentication"],
            "$vpn_cfg_err Invalid local RSA key file path "
              . "\"$local_key_file\".  Filesystem read permission absent.\n");
          } else {
          vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "authentication"],
              "$vpn_cfg_err No RSA key configured."
              . " Use the 'generate vpn rsa-key' command to create it.\n");
          }
        }

        $genout .= "\tleftauth=pubkey\n";
        $genout .= "\trightauth=pubkey\n";
        my $local_key = rsa_pubkey_to_rfc2537(rsa_get_local_pubkey($local_key_file));
        if ( !defined($local_key) || $local_key eq "" ) {
          vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "authentication"],
            "$vpn_cfg_err Unable to determine local public key from local key"
            . " file \"$local_key_file\" for peer \"$peer\".\n");
        } else {
          $genout .= "\tleftsigkey=\"dns:$local_key\"\n";
        }

        my $rsa_key_name = $vcVPN->returnValue(
          "ipsec site-to-site peer $peer authentication rsa-key-name");
        if ( !defined($rsa_key_name) || $rsa_key_name eq "" ) {
          vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "authentication", "rsa-key-name"],
            "$vpn_cfg_err No 'rsa-key-name' specified for peer \"$peer\""
            . " while 'rsa' authentication mode is specified.\n");
        } else {
          my $remote_key =
            $vcVPN->returnValue("rsa-keys rsa-key-name $rsa_key_name rsa-key");
          if ( !defined($remote_key) || $remote_key eq "" ) {
            vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "authentication"],
              "$vpn_cfg_err No remote key configured for rsa key name "
              . "\"$rsa_key_name\" that is specified for peer \"$peer\".\n");
          } else {
            $genout .= "\trightsigkey=\"dns:$remote_key\"\n";
          }
        }
        $genout_secrets .= write_secrets_id_selectors($dhcp_iface, $lip, $right, $authid, $authremoteid);
        $genout_secrets .= ": RSA $local_key_file\n";
      } else {
        vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "authentication"],
          "$vpn_cfg_err Unknown authentication mode \"$auth_mode\" for peer "
          . "\"$peer\" specified.\n");
      }

      #
      # Mark setting for vti.
      # and up/down script hook.
      #
      if ($isVti) {
          my $mark = isVtimarkpresent($peer, $lip);
          if (!defined($mark) || $mark eq '') {
            vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "vti"],
                "$vpn_cfg_err No mark specified for peer \"$peer\" vti\n");
          } else {
            $genout .= "\tmark=$mark\n";
            $genout .= "\tmark_in_sa=yes\n";
          }
          # up/down script hook.
          my $tunName = $vcVPN->returnValue("ipsec site-to-site peer $peer vti bind");
          if (!defined($tunName)) {
            vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "vti", "bind"],
                "$vpn_cfg_err No interface bind specified for peer \"$peer\" vti\n");
          }
          $genout .= "\tleftupdown=\"/usr/lib/ipsec/vti-up-down.sh $tunName\"\n";
      } elsif (! -f '/opt/vyatta/etc/features/vyatta-security-vpn-ipsec-v1/disable-dataplane-ipsec') {
          $genout .= "\tleftupdown=\"/usr/lib/ipsec/vyatta-dataplane-s2s-updown\"\n";
      }

      $genout .= "\tkeyingtries=1\n";

      #
      # Start automatically
      #
      if ($any_peer) {
        $genout .= "\tauto=add\n";
      } else {
        my $conntype = $vcVPN->returnValue("ipsec site-to-site peer $peer connection-type");
        if (defined ($conntype)){
          if ($conntype eq "initiate"){
            $genout .= "\tauto=start\n";
          } elsif ($conntype eq "respond"){
            $genout .= "\tauto=add\n";
          }
        }
        else{
          $genout .= "\tauto=start\n";
        }
      }

      #
      # replay window size
      #
      my $replay_window = $vcVPN->returnValue("ipsec site-to-site peer $peer replay-window");
      if (defined ($replay_window)) {
            $genout .= "\treplay_window=$replay_window\n";
      } else {
            $genout .= "\treplay_window=0\n";
      }

      $conn_head =~ s/\n//;
      $genout .= "#$conn_head";    # to identify end of connection definition
                                   # used by clear vpn op-mode command


      #
      # End of connection section
      #

      add_shunt ($conn, $conn_proto, $leftsubnet, $rightsubnet, $lip, $right, $lprotoport, $rprotoport );

      if ( $needs_passthrough eq 'true' ) {

          # CREATE A PASSTHROUGH CONNECTION
          my $passthrough_conn_head = "\nconn passthrough-peer-$peer-tunnel-$tunnel\n";
          $passthrough_conn_head =~ s/ peer-@/ peer-/;
          $genout .= $passthrough_conn_head;
          if ( $lip eq '0.0.0.0' ) {
            $genout .= "\tleft=%any\n";
          } else {
            $genout .= "\tleft=$lip\n";
          }
          $genout .= "\tright=$right\n";
          $genout .= "\tleftsubnet=$leftsubnet\n";
          $genout .= "\trightsubnet=$leftsubnet\n";
          $genout .= "\ttype=passthrough\n";
          $genout .= "\tleftauth=never\n";
          $genout .= "\trightauth=never\n";
          $genout .= "\tauto=route\n";
          $passthrough_conn_head =~ s/\n//;
          $genout .= "#$passthrough_conn_head";

      }
    }
  }
  #
  # Track DMVPN related changes so that connections can be reloaded/restarted
  # accordingly.
  #
  # Find left over connections that are not configured.
  # reread+reload doesn't bring down existing inbound # connections.
  # Queue them to be closed here.
  #
  my %tunnel_hash;
  if (is_vpn_running()) {
      %tunnel_hash = get_vpnprof_tunnels();
  }

  my %tunnels;
  my @dmvpn_profs = $vcVPN->listNodes('ipsec profile');
  for my $connectid (keys %tunnel_hash) {
      my $tun = $tunnel_hash{$connectid}->{_tunnelnum};
      if (!$tun) {
	  next;
      }
      my $bound=0;
      my $deleted=0;
      my $disabled=0;
      my $reset_needed=0;

      foreach my $prof (@dmvpn_profs) {
	  if ($vcVPN->isDeleted("ipsec profile $prof bind tunnel $tun")) {
	      $deleted=1;
	  }
	  if ($vcVPN->exists("ipsec profile $prof bind tunnel $tun")) {
	      $bound=1;
	      my $espgroup = $vcVPN->returnValue(
		  "ipsec profile $prof esp-group");
	      my $ikegroup = $vcVPN->returnValue(
		  "ipsec profile $prof ike-group");
	      if ($vcVPN->isChanged("ipsec profile $prof ike-group") ||
		  $vcVPN->isChanged("ipsec profile $prof esp-group") ||
		  $vcVPN->isChanged("ipsec profile $prof authentication") ||
		  $vcVPN->isChanged("ipsec esp-group $espgroup") ||
		  $vcVPN->isChanged("ipsec ike-group $ikegroup") ||
		  $vcVPN->isAdded("ipsec profile $prof bind tunnel $tun" )) {
		  $reset_needed=1;
	      }
	  }
      }
      if ($vc->exists("interfaces tunnel $tun disable")) {
	  $disabled=1;
      }
      if (!$bound || $deleted || $disabled) {
	  if ($connectid =~ "(vpnprof-tunnel-|.*-to-.*)") {
	      # Close inbound connections that are not configured.
	      vpn_exec("ipsec stroke down-nb $connectid" . "[*]",
		       "down-nb changed connection $connectid" . "[*]");
	      # reread+reload should remove the inbound connection definition.
	      # Run delete anyway just to be sure.
	      vpn_exec("ipsec stroke delete $connectid",
		       "delete connection $connectid");
	  }
	  if ($tunnels{$tun}) {
	      next;
	  }
	  system("opennhrpctl purge dev $tun");
	  $tunnels{$tun}=1;
      } elsif ($reset_needed) {
	  if ($connectid =~ "(vpnprof-tunnel-|.*-to-.*)") {
	      push(@CHANGED_IKE_SAS, $connectid);
	  }
      }
  }

  if (-e '/etc/dmvpn.conf') {
    $genout .= "\ninclude /etc/dmvpn.conf\n";
    $genout .= "\ninclude /etc/dmvpn.*.conf\n";
  }
  if (-e '/etc/dmvpn.secrets') {
    $genout_secrets .= "\ninclude /etc/dmvpn.secrets\n";
  }
  
} else {

  #
  # remove any previous config lines, so that when "clear vpn ipsec-process"
  # is called it won't find the vyatta keyword and therefore will not try
  # to start the ipsec process.
  #
  $genout = '';
  $genout         .= "# No VPN configuration exists.\n";
  $genout_secrets .= "# No VPN configuration exists.\n";
}

if (
  !(
       defined($config_file)
    && ( $config_file ne '' )
    && defined($secrets_file)
    && ( $secrets_file ne '' )
  )
  )
{
  print "Regular config file output would be:\n\n$genout\n\n";
  print "Secrets config file output would be:\n\n$genout_secrets\n\n";
  exit(0);
}

if ( $vcVPN->isDeleted('.')
    || !$vcVPN->exists('.')
    || $vcVPN->isDeleted('ipsec')
    || !$vcVPN->exists('ipsec') )
{
  if ( Vyatta::Misc::isClusterIP( $vc, 'ipsec' ) ) {
    vpn_die(["security", "vpn", "ipsec"],
     "VPN commit error.  Cluster service is referencing ipsec config.\n");
  }
  if ( is_vpn_running() ) {
    toggle_xfrm_policy(0);
    vpn_exec( 'ipsec stop >&/dev/null', 'stop ipsec' );
  }
  if ( !enableICMP('1') ) {
    vpn_die(["security", "vpn", "ipsec"],
    "VPN commit error.  Unable to re-enable ICMP redirects.\n");
  }
  write_config( $genout, $config_file, $genout_secrets, $secrets_file, $dhcp_if);
  write_charon_logging_conf( $vcVPN );
} else {
  if ( !enableICMP('0') ) {
    vpn_die(["security", "vpn", "ipsec"],
    "VPN commit error.  Unable to disable ICMP redirects.\n");
  }

  write_config( $genout, $config_file, $genout_secrets, $secrets_file, $dhcp_if );
  write_charon_logging_conf( $vcVPN );

 # Assumming that if there was a local IP missmatch and clustering is enabled,
 # then the clustering scripts will take care of starting the VPN daemon.
  if ($clustering_ip) {

# If the local-address is provided by clustering, then just write out the configuration,
# but do not start the VPN daemon

    vpn_log(
"Wrote out configuration to files '$config_file' and '$secrets_file'.  VPN/ipsec daemons not started due to clustering.\n"
      );
      print "Clustering configured - not restarting ipsec\n";
  } else {
    my $update_interval = $vcVPN->returnValue("ipsec auto-update");
    my $update_interval_orig = $vcVPN->returnOrigValue("ipsec auto-update");
    $update_interval_orig = 0 if !defined($update_interval_orig);

    my $systemd_unit_config_path = '/etc/systemd/system/strongswan.service.d/auto-update.conf';
    if ($update_interval && ($update_interval != $update_interval_orig)) {
        # https://bugzilla.redhat.com/show_bug.cgi?id=756787#c9
        my $systemd_unit_config =<<EOF;
[Service]
ExecStart=
ExecStart=/usr/sbin/ipsec start --auto-update $update_interval
EOF
        make_path(dirname($systemd_unit_config_path), { mode => oct(755) });
        write_file($systemd_unit_config_path, \$systemd_unit_config);
    } elsif (!$update_interval && $update_interval_orig) {
        unlink($systemd_unit_config_path);
    }

    if ( is_vpn_running() ) {
        if ($update_interval && ($update_interval != $update_interval_orig)) {
            print "Re-starting IPsec daemon to activate new auto-update interval...\n";
            vpn_exec( 'systemctl restart strongswan.service',
                      're-starting ipsec with updated auto-update interval $update_interval' );
        } elsif (!$update_interval && $update_interval_orig) {
            print "Re-starting IPsec daemon to deactivate auto-update...\n";
            vpn_exec( 'systemctl restart strongswan.service',
                      're-starting ipsec' );
        } else {
	    for my $conn (@CHANGED_IKE_SAS) {
                vpn_exec( "ipsec stroke down-nb ".$conn."[*]",
                          "down-nb deleted/changed IKE SA for connection: $conn" );
            }
	    for my $conn (@CHANGED_CHILD_SAS) {
                vpn_exec( "ipsec stroke down-nb ".$conn."{*}",
                          "down-nb deleted/changed Child SA for connection: $conn" );
            }
	    vpn_exec( 'ipsec rereadall >&/dev/null', 're-read secrets' );
	    vpn_exec( 'ipsec update >&/dev/null',
		      'update changes to ipsec.conf and update' );
        }
    } else {
        vpn_exec( 'systemctl restart strongswan.service', 'start/restart ipsec' );
    }
  }
}

sub opennhrp_is_running {
  return (qx(pgrep opennhrp) ne "");
}

my $ipsec_cfg = Vyatta::Config->new('security vpn ipsec');
my @profs = $ipsec_cfg->listNodes('profile');
foreach my $prof (@profs) {
    my @tuns = $vc->listNodes("interfaces tunnel");
    my $espgroup = $ipsec_cfg->returnValue("profile $prof esp-group");
    my $ikegroup = $ipsec_cfg->returnValue("profile $prof ike-group");
    foreach my $tun (@tuns){
        if ( $ipsec_cfg->exists("profile $prof bind tunnel $tun")) {
            if ( $ipsec_cfg->isChanged("profile $prof ike-group")
                 || $ipsec_cfg->isChanged("profile $prof esp-group")
                 || $ipsec_cfg->isChanged("profile $prof authentication")
                 || $ipsec_cfg->isChanged("esp-group $espgroup")
                 || $ipsec_cfg->isChanged("ike-group $ikegroup")
                 || $ipsec_cfg->isAdded("profile $prof bind tunnel $tun" )) {

		if (opennhrp_is_running()) {
		    system("opennhrpctl purge dev $tun");
               }
            }
        }
    }
}

#
# Return success
#
exit 0;

sub write_config {
  my ( $genout, $config_file, $genout_secrets, $secrets_file, $dhcp_if ) = @_;
  my $config_file_shunts = $config_file . ".shunts";
  my $genout_any = "";
  my $genout_secret = "";

  open my $output_config_shunts, '>', $config_file_shunts
    or die "Can't open $config_file_shunts: $!";
  print ${output_config_shunts} $genout_shunts;
  close $output_config_shunts;

  open my $output_config, '>', $config_file
    or die "Can't open $config_file: $!";
  print ${output_config} "# generated by $scriptname\n";
  print ${output_config} "\ninclude $config_file_shunts\n\n";
  print ${output_config} $genout;
  close $output_config;

  my @secrets = split("\n", $genout_secrets);
  foreach my $val (@secrets) {
   if ($val =~ "%any") {
	$genout_any .=  $val . "\n";
   } else {
        $genout_secret .= $val . "\n";
   }
  }

  open my $output_secrets, '>', $secrets_file
    or die "Can't open $secrets_file: $!";
  chmod(0600, $output_secrets);
  print ${output_secrets} $genout_secret;
  print ${output_secrets} $genout_any;
  close $output_secrets;
  dhcp_hook($dhcp_if);

  return;
}

sub get_x509 {
  my ($peer) = @_;
  # Setup x509, based on the L2TP x509 code
  #
  ## check that proper nodes are defined.
  my @cacerts = $vcVPN->returnValues("x509 ca-certs");

  my $path = "vpn ipsec site-to-site peer $peer authentication x509 ";
  my $cacrt = $vcVPN->returnValue("ipsec site-to-site peer $peer authentication x509 ca-cert-file");
  vpn_die([split(' ', ($path."ca-cert-file"))],
          "$vpn_cfg_err No CA certificate for peer \"$peer\" specified.\n") if !defined($cacrt) && (!@cacerts);
  my $crl = $vcVPN->returnValue("ipsec site-to-site peer $peer authentication x509 crl-file");
  my $crt = $vcVPN->returnValue("ipsec site-to-site peer $peer authentication x509 cert-file");
  vpn_die([split(' ', ($path."cert-file"))],
          "$vpn_cfg_err No Certificate for peer \"$peer\" specified.\n") if !defined($crt);
  my $key = $vcVPN->returnValue("ipsec site-to-site peer $peer authentication x509 key file");
  vpn_die([split(' ', ($path."key-file"))],
          "$vpn_cfg_err No Key for peer \"$peer\" specified.\n") if !defined($key);

  # Verify the files exist
  vpn_die([split(' ', ($path."ca-cert-file"))] , "Invalid ca-cert-file \"$cacrt\"")
    if defined($cacrt) && (! -f $cacrt);
  vpn_die([split(' ', ($path."cert-file"))] , "Invalid cert-file \"$crt\"")
    if (! -f $crt);
  vpn_die([split(' ', ($path."key-file"))] , "Invalid key-file \"$key\"" )
    if (! -f $key);

  my $auth_str = "\tleftauth=pubkey\n";
  $auth_str .= "\trightauth=pubkey\n";
  $auth_str .= "\tleftsigkey=%cert\n";
  $auth_str .= "\trightsigkey=%cert\n";
  $auth_str .= "\tleftcert=$crt\n";
  $auth_str .= "\tleftsendcert=yes\n";
  return $auth_str;
}

sub get_x509_secret {
  my ($peer) = @_;
  my $key_file = $vcVPN->returnValue("ipsec site-to-site peer $peer authentication x509 key file");
  my $key_pass = $vcVPN->returnValue("ipsec site-to-site peer $peer authentication x509 key password");

  my $key_type = get_pki_key_type($key_file);
  $key_type = (defined($key_type) ? uc($key_type) : 'RSA');

  my $pstr = (defined($key_pass) ? " \"$key_pass\"" : '');
  my $str = ": $key_type ${key_file}$pstr \n";
  return $str;
}

sub get_dhcp_addr {
  my ($dhcp_iface, $peer, $peer_proto) = @_;
  vpn_die(["security", "vpn", "ipsec", "site-to-site", "peer", $peer, "dhcp-interface"],
    "$vpn_cfg_err The specified interface is not configured for dhcp.")
    if (($peer_proto == 4 && !(Vyatta::DHCPClient::is_dhcp_enabled($dhcp_iface,'cfg_mode'))) ||
        ($peer_proto == 6 &&
        !(Vyatta::Misc::is_dhcpv6_enabled($dhcp_iface,0))));
  my @dhcp_addr = Vyatta::Misc::getIP($dhcp_iface, $peer_proto);
  if ($peer_proto == 4) {
     my $addr = pop(@dhcp_addr);
     if (!defined($addr)){
         $addr = '';
        return $addr;
     }
     @dhcp_addr = split(/\//, $addr); 
     $addr = $dhcp_addr[0];
     return $addr;
  }
  my @v6_addr;
  while (1) {
     my $addr = pop(@dhcp_addr);
     if (!defined($addr)){
         $addr = '';
        return $addr;
     }
     @v6_addr = split(/\//, $addr); 
     $addr = $v6_addr[0];
     # dont return link local address.
     if ( $addr !~ /^fe80:/) {
        return $addr;
     }
  }

  # Should never be reached.
  die 'Could not determine DHCP address.';
}

sub dhcp_hook {
  my ($dhcp_iface) = @_;
  my $str = '';
  if ($dhcp_iface > 0){
    $str =<<EOS;
#!/bin/sh
/opt/vyatta/bin/vyatta-ipsec-dhcp.pl --interface=\"\$interface\" --new_ip=\"\$new_ip_address\" --reason=\"\$reason\" --old_ip=\"\$old_ip_address\" --old_ip6=\"\$old_ip6_address\" --new_ip6=\"\$new_ip6_address\"
EOS
  }
  my $hook = "/etc/dhcp/dhclient-exit-hooks.d/ipsecd";
  open my $dhcp_hook, '>', $hook
    or die "cannot open $hook";
  print ${dhcp_hook} $str;
  close $dhcp_hook;

  return;
}

sub toggle_xfrm_policy {
    return if
        -f '/opt/vyatta/etc/features/vyatta-security-vpn-ipsec-v1/disable-dataplane-ipsec';

  vpn_exec( "sysctl net.ipv4.conf.all.disable_policy=$_[0] >&/dev/null",
	    'toggle ipv4 all policy');
  vpn_exec( "sysctl net.ipv4.conf.default.disable_policy=$_[0] >&/dev/null",
	    'toggle ipv4 default policy');
  if ( -f '/opt/vyatta/etc/features/vyatta-security-vpn-ipsec-v1/enable-dataplane-ipsec6' ) {
      vpn_exec( "sysctl net.ipv6.conf.all.disable_policy=$_[0] >&/dev/null",
		'toggle ipv6 all policy');
      vpn_exec( "sysctl net.ipv6.conf.default.disable_policy=$_[0] >&/dev/null",
		'toggle ipv6 default policy');
  }
  my @DpIntfs = grep { /^(dp|vfp)\d+/ } Vyatta::Misc::getInterfaces();
  foreach my $intf (@DpIntfs) {
    $intf =~ tr /./\//;
    vpn_exec("sysctl net.ipv4.conf.$intf.disable_policy=$_[0] >&/dev/null",
	     'VPN toggle net.ipv4.conf.intf.disable_policy');
    if ( -f '/opt/vyatta/etc/features/vyatta-security-vpn-ipsec-v1/enable-dataplane-ipsec6' ) {
	vpn_exec("sysctl net.ipv6.conf.$intf.disable_policy=$_[0] >&/dev/null",
		 'VPN toggle net.ipv6.conf.intf.disable_policy');
    }
  }

  return;
}

sub write_secrets_id_selectors {
  my($dhcp_iface, $lip, $right, $authid, $authremoteid) = @_;

  my $id_selectors;
  if (defined($dhcp_iface) && $lip eq '') {
    $id_selectors .= "# $right ";
  } else {
    $id_selectors .= "$lip $right ";
  }
  if ( defined ($authid) ) {
    $id_selectors .= "$authid ";
  }
  if ( defined ($authremoteid) ) {
    $id_selectors .= "$authremoteid ";
  }
  return $id_selectors;
}
# end of file
